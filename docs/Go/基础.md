---
title: Go 基础
createTime: 2017-02-12
---

## 变量

变量的声明与初始化有 3 种方式：

- `var vname1, vname2, vname3 type = v1, v2, v3`
- `var vname1, vname2, vname3 = v1, v2, v3`
- `vname1, vname2, vname3 := v1, v2, v3`

> - `:=` 只能用在函数内部，所以一般用 `var` 来定义全局变量
> - `_`（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃
> - 大写字母开头的变量或函数是公开的，小写字母开头的是私有的

## 基本类型

| 类型      | 含义       | 例子          | 零值  | 备注         |
|-----------|------------|---------------|-------|--------------|
| bool      |            | {true, false} | false |
| int       | 整数       |               | 0     |              |
| unit      | 无符号整数 |               | 0x0   |              |
| byte      | 字符       |               | 0x0   | unit8 的别称 |
| rune      |            |               | 0     | int32 的别称 |
| complex64 | 复数       | 5 + 5i        |       |              |
| string    | 字符串     | "hello"       | ""    |              |

### 字符串

- 字符串用 `""` 或 ``` `` ``` 定义
- 字符串不可变
- `+` 拼接字符串
- `` ` `` 括起来的字符串为 raw 字符串，没有字符转义

### 数组

#### 声明

```go
var arr [n]type
```

#### 访问

```go
var arr [10]int  // 声明了一个int类型的数组
arr[0] = 42      // 数组下标是从0开始的
arr[1] = 13      // 赋值操作
fmt.Printf("The first element is %d\n", arr[0])  // 获取数据，返回42
fmt.Printf("The last element is %d\n", arr[9]) //返回未赋值的最后一个元素，默认返回0
```

#### 初始化

```go
a := [3]int{1, 2, 3} // 声明了一个长度为3的int数组
b := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0
c := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度

// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}
// 上面的声明可以简化，直接忽略内部的类型
easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
```

> - 长度也是数组类型的一部分
> - 作为参数传入函数的时候是值传递

### Slice

#### 声明

```go
// 和声明 array 一样，只是少了长度
var fslice []int
```

#### 初始化

```go
slice := []byte{'a', 'b', 'c', 'd'}
```

> - Slice 是引用
> - `ar[:n]` 等价于 `ar[0:n]`
> - `ar[n:]` 等价于 `ar[n:len(ar)]`
> - `ar[:]` 等价于 `ar[0:len(ar)]`
> - `append` 函数有可能改变 `slice` 所引用的数组

### Map

#### 声明

```go
var v map[keyType]valueType
```

#### 初始化

```go
numbers := make(map[string]int)

rating := map[string]float32{"C":5, "Go":4.5, "Python":4.5, "C++":2 }
```

#### 访问

```go
numbers["one"] = 1
numbers["two"] = 2
numbers["three"] = 3

// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true
csharpRating, ok := rating["C#"]
if ok {
    fmt.Println("C# is in the map and its rating is ", csharpRating)
} else {
    fmt.Println("We have no rating associated with C# in the map")
}

delete(rating, "C")  // 删除key为C的元素
```

> - map 是无序的
> - map 非线程安全
> - map 是引用

## 流程控制

### `if`

```go
// 计算获取值x,然后根据x返回的大小，判断是否大于10。
if x := computedValue(); x > 10 {
    fmt.Println("x is greater than 10")
} else {
    fmt.Println("x is less than 10")
}

//这个地方如果这样调用就编译出错了，因为x是条件里面的变量
fmt.Println(x)

if integer == 3 {
    fmt.Println("The integer is equal to 3")
} else if integer < 3 {
    fmt.Println("The integer is less than 3")
} else {
    fmt.Println("The integer is greater than 3")
}
```

> - `if` 条件判断语句里的新变量作用域为该条件逻辑块

### `for`

```go
for index:=0; index < 10 ; index++ {
    sum += index
}

// while
for sum < 1000 {
    sum += sum
}

// range slice 或 map
for k, v := range map {
    fmt.Println("map's key:", k)
    fmt.Println("map's value:", v)
}
```

> - `break` 跳出当前循环
> - `continue` 跳过本次循环

### `switch`

```go
i := 10
switch i {
case 1:
    fmt.Println("i is equal to 1")
case 2, 3, 4:
    fmt.Println("i is equal to 2, 3 or 4")
case 10:
    fmt.Println("i is equal to 10")
default:
    fmt.Println("All I know is that i is an integer")
}
```

## 函数

```go
func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
    //这里是处理逻辑代码
    //返回多个值
    return output1, output2
}
```

### 可变数目的参数

```go
func myfunc(arg ...int) {}
```

> arg 是 `int` 类型的 slice

### 传值与传指针

默认传值。

> `channel`、`slice` 和 `map` 是引用，可以直接传递和不消耗很多资源

### `defer`

> `defer` 是逆序执行的

### 函数作为值和类型

```go
type typeName funct(input1 inputType1, input2 inputType2[, ...]) (result1 resultType1[, ...])
```

> - 所有拥有相同的参数，相同返回值的函数为同一种类型
> - 把函数当作值或类型适合写通用接口

## struct

### 初始化

```go
type person struct {
    name string
    age int
}

P := person{"Tom", 25} // 按顺序初始化
P := person{age:24, name: "Tom"} // 指定 field
P := new(Person) // new 返回 field 初始化为零值的结构体的指针
```

### 匿名字段

```go
type Human struct {
    name string
    age int
    weight int
}

type Student struct {
    Human  // 匿名字段，那么默认Student就包含了Human的所有字段
    speciality string
}
```

> - 优先访问外层字段

## 面向对象

### 声明

```go
func (r ReceiverType) funcName(parameters) (results)
```

### 继承

含匿名字段的 struct 可以调用匿名字段的方法。

### 变量的类型

```go
value, ok := element.(T)

switch value := element.(type) {
    case int:
        fmt.Printf("list[%d] is an int and its value is %d\n", index, value)
    case string:
        fmt.Printf("list[%d] is a string and its value is %s\n", index, value)
    case Person:
        fmt.Printf("list[%d] is a Person and its value is %s\n", index, value)
    default:
        fmt.Println("list[%d] is of a different type", index)
}
```

> `element.(type)` 语法只能在 `switch` 里使用

## 并发

### channel

> - 生产者关闭 channel，消费者不行

```go
```

```go
```

```go
```

```go
```
